# -*- coding: utf-8 -*-
"""CISC 246 - Programming Assignment 2 - Ben Phan - Fall 2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/162b5q1P9-_s-qdljfu0kq7GoRcQszxDx

#TASK 1
CONGRUENT MOD
"""

# (1, 9, -8, 35) = [-8, 1, 10, 19, 28]
# (2, 5, -20, 7) =

def congruent_mod(b, n, lower, upper) -> list:
    congruent_list = []
    remainder = b % n
    for i in range(lower, upper + 1):
        if i % n == remainder:
            congruent_list.append(i)
    return congruent_list




#===========TEST CASES FOR congruent_mod===========

import unittest

class TestCongruentMod(unittest.TestCase):
    def test1_congruent_mod(self):
      'test cases function for congruent_mod()'
      self.assertEqual(congruent_mod(1, 9, -8, 35), [-8, 1, 10, 19, 28])

    def test2_congruent_mod(self):
      'test cases function for congruent_mod()'
      self.assertEqual(congruent_mod(2, 5, -20, 7), [-18, -13, -8, -3, 2, 7])

runner = unittest.TextTestRunner()
suite = unittest.TestSuite()
suite.addTest(unittest.TestLoader().loadTestsFromTestCase(TestCongruentMod))
runner.run(suite)

"""#TASK 2
DIVISORS
"""

def divisors(x):
    divisors_list = []
    for i in range(1, x + 1): # i = 1(can't mod 0)
        if x % i == 0:
            divisors_list.append(i)
    return divisors_list




#===========TEST CASES FOR divisor===========

# Unittest reference: Hunter Alzate Programming Assignment 1
import unittest

class TestDivisor(unittest.TestCase):
    def test1_divisor(self):
      'test cases function for divisor()'
      self.assertEqual(divisors(20), [1, 2, 4, 5, 10, 20])

    def test2_divisor(self):
      'test cases function for divisor()'
      self.assertEqual(divisors(99), [1, 3, 9, 11, 33, 99])

    def test3_divisor(self):
      'test cases function for divisor()'
      self.assertEqual(divisors(191), [1, 191])

runner = unittest.TextTestRunner()
suite = unittest.TestSuite()
suite.addTest(unittest.TestLoader().loadTestsFromTestCase(TestDivisor))
runner.run(suite)

"""#TASK 3
GCD
"""

def greatest_common_divisor(a, b):
    return max([div for div in divisors(a) if div in divisors(b)])

# # print(greatest_common_divisor(12, 18))  # 6
# # print(greatest_common_divisor(20, 30))  # 10
# # print(greatest_common_divisor(33, 6))   # 3
# # print(greatest_common_divisor(10, 7))   # 1




#===========TEST CASES FOR greatest_common_divisor===========

import unittest

class TestGreatestCommonDivisor(unittest.TestCase):
    def test1_greatest_common_divisor(self):
      'test cases function for divisor()'
      self.assertEqual(greatest_common_divisor(12, 18), 6)

    def test2_greatest_common_divisor(self):
      'test cases function for divisor()'
      self.assertEqual(greatest_common_divisor(20, 30), 10)

    def test3_greatest_common_divisor(self):
      'test cases function for divisor()'
      self.assertEqual(greatest_common_divisor(33, 6), 3)

    def test4_greatest_common_divisor(self):
      'test cases function for divisor()'
      self.assertEqual(greatest_common_divisor(10, 7), 1)

runner = unittest.TextTestRunner()
suite = unittest.TestSuite()
suite.addTest(unittest.TestLoader().loadTestsFromTestCase(TestGreatestCommonDivisor))
runner.run(suite)

"""#TASK 4

MULTIPLICATIVE_INVERSE

"""

def multiplicative_inverse(a, b, n):
    if (a * b) % n == 1:
        return True
    return False

# print(multiplicative_inverse(10, 2, 4)) # False
# print(multiplicative_inverse(10, 5, 7)) # True
# print(multiplicative_inverse(4, 9, 7))  # True
# print(multiplicative_inverse(1, 43, 2)) # True




#===========TEST CASES FOR multiplicative_inverse===========

import unittest

class TestMultiplicativeInverse(unittest.TestCase):
    def test1_multiplicative_inverse(self):
      'test cases function for divisor()'
      self.assertEqual(multiplicative_inverse(10, 2, 4), False)

    def test2_multiplicative_inverse(self):
      'test cases function for divisor()'
      self.assertEqual(multiplicative_inverse(10, 5, 7), True)

    def test3_multiplicative_inverse(self):
      'test cases function for divisor()'
      self.assertEqual(multiplicative_inverse(4, 9, 7), True)

    def test4_multiplicative_inverse(self):
      'test cases function for divisor()'
      self.assertEqual(multiplicative_inverse(1, 43, 2), True)

runner = unittest.TextTestRunner()
suite = unittest.TestSuite()
suite.addTest(unittest.TestLoader().loadTestsFromTestCase(TestMultiplicativeInverse))
runner.run(suite)

"""#TASK 5

RELATIVELY PRIME
"""

import math

def isPrime(a):
    if a < 2: #0, 1 != prime
        return False
    for i in range (2, int(math.sqrt(a))): # cut the loop in square?
        if a % i == 0:
            return False
    return True

def relatively_prime(a, b):
    if greatest_common_divisor(a, b) == 1:
        return True
    return False




#===========TEST CASES FOR relatively_prime===========

import unittest

class TestRelativelyPrime(unittest.TestCase):
    def test1_relatively_prime(self):
      'test cases function for divisor()'
      self.assertEqual(relatively_prime(57, 171), False)

    def test2_relatively_prime(self):
      'test cases function for divisor()'
      self.assertEqual(relatively_prime(57, 1911), False)

    def test3_relatively_prime(self):
      'test cases function for divisor()'
      self.assertEqual(relatively_prime(57, 191), True)

    def test4_relatively_prime(self):
      'test cases function for divisor()'
      self.assertEqual(relatively_prime(43, 2), True)

runner = unittest.TextTestRunner()
suite = unittest.TestSuite()
suite.addTest(unittest.TestLoader().loadTestsFromTestCase(TestRelativelyPrime))
runner.run(suite)

# print(relatively_prime(57, 171)) # False
# print(relatively_prime(57, 1911)) # False
# print(greatest_common_divisor(57, 1911))
# print(relatively_prime(57, 191)) # True
# print(relatively_prime(43, 2)) # True

"""#TASK 6

##a) The Euclidean algorithm is an efficient algorithm to find the GCD of 2 integers. The principal is that the GCD stays the same even if the larger number is replaced with the difference of the numbers -> The GCD of A and B is the same as the GCD of b and a % b -> Keep recursively set a = a % b and let b = previous a until b == 0 and return a as the GCD.

##### Source: https://en.wikipedia.org/wiki/Euclidean_algorithm

##b) Code: Rewrite Task 5
"""

def relatively_prime_upgraded(a, b):
    while (b != 0):
        temp = b
        b = a % b
        a = temp
    if (a == 1):
        return True
    return False

# print(relatively_prime_upgraded(57, 171)) # False
# print(relatively_prime_upgraded(57, 1911)) # False
# print(relatively_prime_upgraded(57, 191)) # True
# print(relatively_prime_upgraded(43, 2)) # True




#===========TEST CASES FOR relatively_prime_upgraded===========

import unittest

class TestRelativelyPrimeUpgraded(unittest.TestCase):
    def test1_relatively_prime_upgraded(self):
      'test cases function for divisor()'
      self.assertEqual(relatively_prime_upgraded(57, 171), False)

    def test2_relatively_prime_upgraded(self):
      'test cases function for divisor()'
      self.assertEqual(relatively_prime_upgraded(57, 1911), False)

    def test3_relatively_prime_upgraded(self):
      'test cases function for divisor()'
      self.assertEqual(relatively_prime_upgraded(57, 191), True)

    def test4_relatively_prime_upgraded(self):
      'test cases function for divisor()'
      self.assertEqual(relatively_prime_upgraded(43, 2), True)

runner = unittest.TextTestRunner()
suite = unittest.TestSuite()
suite.addTest(unittest.TestLoader().loadTestsFromTestCase(TestRelativelyPrimeUpgraded))
runner.run(suite)

"""#TASK 7

Move Over Encrypt
"""

def move_over_encrypt(word: str, key: int) -> str:
    result = list(word)
    word_len = len(word)
    for i in range(0, word_len):
        result[(i + key) % word_len] = word[i]     # can't use set by index on string

    return "".join(result)

# print(move_over_encrypt('CODE', 2))         #['D', 'E', 'C', 'O']
# print(move_over_encrypt("HELLO", 2))        #['L', 'O', 'H', 'E', 'L']
# print(move_over_encrypt("CHECKFLAG", 2))    #['A', 'G', 'C', 'H', 'E', 'C', 'K', 'F', 'L']
# print(move_over_encrypt("RUBIK", 5))        #['R', 'U', 'B', 'I', 'K']




#===========TEST CASES FOR move_over_encrypt===========

import unittest

class TestMoveOverEncrypt(unittest.TestCase):
    def test1_move_over_encrypt(self):
      'test cases function for divisor()'
      self.assertEqual(move_over_encrypt('CODE', 2), "DECO")

    def test2_move_over_encrypt(self):
      'test cases function for divisor()'
      self.assertEqual(move_over_encrypt("HELLO", 2), "LOHEL")

    def test3_move_over_encrypt(self):
      'test cases function for divisor()'
      self.assertEqual(move_over_encrypt("CHECKFLAG", 2), "AGCHECKFL")

    def test4_move_over_encrypt(self):
      'test cases function for divisor()'
      self.assertEqual(move_over_encrypt("RUBIK", 5), "RUBIK")

runner = unittest.TextTestRunner()
suite = unittest.TestSuite()
suite.addTest(unittest.TestLoader().loadTestsFromTestCase(TestMoveOverEncrypt))
runner.run(suite)

"""#TASK 8
Skip Ahead Encrypt
"""

def skip_ahead_encrypt(word: str, key: int) -> str:
    word_len = len(word)
    if (greatest_common_divisor(word_len, key) != 1):
        return "Invalid keys"
    result = list(word)
    for i in range(0, word_len):
        result[(i * key) % word_len] = word[i]
    return "".join(result)




#===========TEST CASES FOR skip_ahead_encrypt===========

import unittest

class TestMoveOverEncrypt(unittest.TestCase):
    def test1_skip_ahead_encrypt(self):
      'test cases function for divisor()'
      self.assertEqual(skip_ahead_encrypt('CODE', 2), "Invalid keys")

    def test2_skip_ahead_encrypt(self):
      'test cases function for divisor()'
      self.assertEqual(skip_ahead_encrypt("ERRORS", 3), "Invalid keys")

    def test3_skip_ahead_encrypt(self):
      'test cases function for divisor()'
      self.assertEqual(skip_ahead_encrypt("DEPARTURES", 4), "Invalid keys")

    def test4_skip_ahead_encrypt(self):
      'test cases function for divisor()'
      self.assertEqual(skip_ahead_encrypt("DEPARTURES", 3), "DRREETPSUA")

    def test5_skip_ahead_encrypt(self):
      'test cases function for divisor()'
      self.assertEqual(skip_ahead_encrypt("RACECARS", 4), "Invalid keys")

    def test6_skip_ahead_encrypt(self):
      'test cases function for divisor()'
      self.assertEqual(skip_ahead_encrypt('CHECKFLAG', 2), "CFHLEACGK")

runner = unittest.TextTestRunner()
suite = unittest.TestSuite()
suite.addTest(unittest.TestLoader().loadTestsFromTestCase(TestMoveOverEncrypt))
runner.run(suite)

# print(skip_ahead_encrypt('CODE', 2))        # Invalid keys
# print(skip_ahead_encrypt("ERRORS", 3))      # Invalid keys
# print(skip_ahead_encrypt("DEPARTURES", 4))  # Invalid keys
# print(skip_ahead_encrypt("DEPARTURES", 3))  # DRREETPSUA
# print(skip_ahead_encrypt("RACECARS", 4))    # Invalid keys
# print(skip_ahead_encrypt('CHECKFLAG', 2))   # CFHLEACGK